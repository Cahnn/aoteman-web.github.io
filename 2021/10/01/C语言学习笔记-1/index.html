<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Hexo</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                首页
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                归档
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                标签
            </a>
            

            
            <a href="/about/" class="header-nav-link">
                关于
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">Alexis's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    <article class="post-whole">
        <div class="post-title">
            <h2 class="title">C语言学习笔记</h2>
            <div class="post-meta">
                <span class="post-time">2021-10-01</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a>
                    
                </span>
                
                <span class="post-visit"> 阅读次数：<span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
        <div class="post-toc" id="post-toc">
    <strong class="post-toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">一、顺序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-%E8%80%83%E6%9F%A5%E5%87%BD%E6%95%B0scanf-%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%85%A5"><span class="toc-text">1、 考查函数scanf()的格式输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-%E8%80%83%E6%9F%A5%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6"><span class="toc-text">2、 考查格式字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%80%83%E6%9F%A5C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-text">3、考查C语言的赋值语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81printf%E5%87%BD%E6%95%B0%E5%9F%9F%E5%AE%BD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4、printf函数域宽描述符的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81C%E8%AF%AD%E5%8F%A5"><span class="toc-text">5、C语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E2%80%9D%E7%A9%BA%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0%E5%9C%A8%E4%BB%BB%E4%BD%95%E4%BD%8D%E7%BD%AE%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E2%80%9D-%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84"><span class="toc-text">1、”空语句出现在任何位置都不会影响程序运行”  是错误的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E5%8F%AB%E2%80%9C%E7%A9%BA%E8%AF%AD%E5%8F%A5%E2%80%9D%EF%BC%9A"><span class="toc-text">2、什么叫“空语句”：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%95%B4%E5%9E%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">6、整型无符号数的输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81-u%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E6%8C%89%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E5%9E%8B%E6%95%B0"><span class="toc-text">1、%u的作用是按无符号的十进制形式输出整型数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA"><span class="toc-text">7、数据输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-text">二、选择结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81switch%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">1、switch语句的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%80%BB%E8%BE%91%E2%80%9C%E6%88%96%E2%80%9D%E8%BF%90%E7%AE%97"><span class="toc-text">2、逻辑“或”运算   ||</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%A2%9E%E3%80%81%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">3、自增、自减运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4、C语言基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">5、关系表达式和逻辑表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC"><span class="toc-text">6、函数传值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">1、值传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">2、引用传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-text">3、指针传递</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">三、循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81do-while%E8%AF%AD%E5%8F%A5"><span class="toc-text">1、do-while语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="toc-text">四、字符型数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"><span class="toc-text">1、字符常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">2、转义字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">五、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8D%E5%A4%8D%E8%B0%83%E7%94%A8"><span class="toc-text">1、函数的反复调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">2、C语言中的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9C%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%98%AF%E6%A3%80%E6%9F%A5%E8%AF%AD%E6%B3%95%E7%9A%84%EF%BC%8C%E8%8B%A5%E5%8F%91%E7%8E%B0%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%9C%89%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%EF%BC%8C%E5%88%99%E7%B3%BB%E7%BB%9F%E4%BC%9A%E6%8F%90%E7%A4%BA%E5%87%BA%E9%94%99%E4%BF%A1%E6%81%AF"><span class="toc-text">1、C语言在编译过程中是检查语法的，若发现源程序有语法错误，则系统会提示出错信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E7%94%B1%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%8C%E6%97%A0%E8%BF%87%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2、子程序的作用是由函数来完成的，无过程的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8"><span class="toc-text">3、函数不可以嵌套定义，但可以嵌套使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">3、C语言函数的缺省的函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81int-f-%E8%A1%A8%E7%A4%BAf%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B8%A6%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%80%BC%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8C%87%E9%92%88%E5%80%BC%E6%98%AF%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E3%80%82"><span class="toc-text">4、int * f() 表示f是一个函数，带回一个指针值，这个指针值是指向一个整型数据的。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">六、地址和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BF%90%E7%AE%97"><span class="toc-text">1、两个指针变量之间不能进行加运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">2、指针变量的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-text">3、指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4、指针的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%9C%A816%E4%BD%8D%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E4%B8%8A%EF%BC%8C%E8%8B%A5%E6%9C%89%E5%AE%9A%E4%B9%89int-a-10-20-30-p-a"><span class="toc-text">1、在16位编译系统上，若有定义int a[]&#x3D;{10,20,30},*p&#x3D;&amp;a;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%80%9A%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-text">2、通过字符串指针进行字符长度的计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3、指针变量作函数参数的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5、指针变量的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81"><span class="toc-text">1、</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E2%80%9C-b-a%E2%80%9D-%E8%A1%A8%E7%A4%BA%E5%B0%86%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8Fa%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%80%BC%E8%B5%8B%E7%BB%99-b-%E5%8D%B3%E5%B0%86a%E6%89%80%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6%E5%88%B0b%E6%89%80%E6%8C%87%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">2、“ *b&#x3D; *a” 表示将指针变量a所指向的值赋给 *b,即将a所值字符串复制到b所指内存空间</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-text">6、函数指针的运用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">7、常见的指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E8%A1%8C%E6%8C%87%E9%92%88"><span class="toc-text">8、行指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%88%97%E6%8C%87%E9%92%88"><span class="toc-text">9、列指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">七、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">1、通过指针引用数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">2、数组指针的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">3、指向指针的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%96%E5%80%BC"><span class="toc-text">4、二维数组的取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%80%89%E6%8B%A9%E6%B3%95%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">5、选择法的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">6、数组的定义和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">7、函数返回数组中的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">8、数组元素的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">9、指向数组元素的指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">八、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81strcpy-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">1、strcpy()函数的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%8B%B7%E8%B4%9D"><span class="toc-text">2、字符串的连接和拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-text">3、字符串长度的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">4、字符串与库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">5、字符数组与字符串的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81-strcmp-%E5%87%BD%E6%95%B0"><span class="toc-text">6、 strcmp()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81puts-%E5%87%BD%E6%95%B0"><span class="toc-text">7、puts()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-text">8、字符串的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81getchar"><span class="toc-text">1、getchar()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81scanf"><span class="toc-text">2、scanf()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81gets"><span class="toc-text">3、gets()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81getc"><span class="toc-text">4、getc()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E4%BA%A4%E6%8D%A2"><span class="toc-text">9、指针变量值的交换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%AF%B9%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA"><span class="toc-text">九、对函数的进一步讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">1、指针数组main函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-text">2、函数的递归调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-text">十、C语言中用户标识符的作用和存储类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-text">1、函数中变量的存储类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2、变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">3、变量存储属性的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">4、全局变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">5、静态局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-text">6、函数形参的存储类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-text">十一、编译预处理和动态存储分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1、对C语言宏定义的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">2、带参数的宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">3、结构体的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81malloc%E5%87%BD%E6%95%B0"><span class="toc-text">4、malloc函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81calloc%E5%87%BD%E6%95%B0"><span class="toc-text">5、calloc函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">6、宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">7、预处理的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E5%92%8C%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">十二、结构体、共用体和用户定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1、结构体与共用体的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2、共用体类型数据的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3、结构体定义变量的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%85%88%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%86%8D%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-text">1、先定义结构体类型，再定义结构体变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-text">2、定义结构体类型的同时，定义结构体变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%B8%8D%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-text">3、不定义结构体类型，直接定义结构体变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%94%A8typedef%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%8F%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">4、用typedef来定义结构体变量及类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">4、链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">十三、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1、位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9A"><span class="toc-text">2、位运算符优先级：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6"><span class="toc-text">十四、文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81feof-%E5%87%BD%E6%95%B0"><span class="toc-text">1、feof()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">2、C语言中的文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">3、打开文件的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">4、二进制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81C%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5、C文件的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81fread-%E5%87%BD%E6%95%B0%E5%92%8Cfwrite-%E5%87%BD%E6%95%B0"><span class="toc-text">6、fread()函数和fwrite()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81fread"><span class="toc-text">1、fread()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81fwrite"><span class="toc-text">2、fwrite()</span></a></li></ol></li></ol></li></ol></li></ol>
    <div class="back-to-top" id="back-to-top">
        <a href="javascript:void(0);">回到顶部</a>
    </div>
</div>
        <div class="post-content">
            <h2 id="一、顺序结构"><a href="#一、顺序结构" class="headerlink" title="一、顺序结构"></a>一、顺序结构</h2><h3 id="1、-考查函数scanf-的格式输入"><a href="#1、-考查函数scanf-的格式输入" class="headerlink" title="1、 考查函数scanf()的格式输入"></a>1、 考查函数scanf()的格式输入</h3><blockquote>
<p><strong>scanf()语句的格式：scanf(格式控制,地址列表)</strong></p>
<p>格式控制的主要作用：指定输入时的数据转换格式</p>
<p>“地址列表”是由若干个地址组成的列表，可以是变量的地址，或字符串的首地址。</p>
<p>通过scanf函数从键盘输入数据时，如果在scanf的格式控制串中插入其他字符，则在输入时按一一对应位置输入这些字符，即可得到正确的输入结果。</p>
</blockquote>
<p>为啥scanf有时要加取地址运算符有时却不用？</p>
<p>举例：</p>
<p>Char name[40];</p>
<p>Int a;</p>
<p>Scanf(“%s”,name);</p>
<p>Scanf(“%d”,&amp;a);</p>
<p>—因为a是整型变量名，所以scanf要取得这个变量在内存中的地址；</p>
<p>而name是char数组，本身指向这个数组首地址。</p>
<p>也就是说a里面保存的是内容，name里面保存的是地址本身</p>
<p>—<strong>&amp;表示取地址，而数组不要后面的[]就表示首地址。</strong></p>
<p>C语言如何为数组赋值？     <strong>只要有[]就要加上取值运算符</strong></p>
<p>Char name[20];</p>
<p>1）、为数组赋值：scanf(“%s\n”,name);  // 不用加取值运算符</p>
<p>​            name即数组首地址，可以用name++为后面元素赋值</p>
<p>2）、为数组元素赋值：scanf(“%s”,&amp;name[1]);  // 要加取值运算符  </p>
<p><strong>如果在“格式控制”字符串中除了格式说明以外还有其他字符，则在输入数据时应输入与这些字符相同的字符。</strong></p>
<p>eg:数据输入形式为scanf(“m=%dn=%dp=%d”,&amp;m,&amp;n,&amp;p);</p>
<p>在输入数据时，必须输入”m=”、“n=”、“p=”且中间不能含有空格</p>
<h3 id="2、-考查格式字符"><a href="#2、-考查格式字符" class="headerlink" title="2、 考查格式字符"></a>2、 考查格式字符</h3><p>d  –&gt;  以十进制形式输出带字符整数(正数不输出符号)</p>
<p>o   –&gt;   以八进制形式输出<strong>无符号整数</strong>（不输出前缀0）</p>
<p>x，X   —〉  以十六进制形式输出<strong>无符号整数</strong>(不输出前缀Ox)</p>
<p>u   —〉  以十进制形式输出无符号整数</p>
<p>f  —–〉  输出单精度浮点型数据（float）</p>
<p>lf   —–&gt;  输出双精度浮点型数据</p>
<p>e、E   —〉  以指数形式输出单双精度实数</p>
<p>c    —〉   输出单个字符</p>
<p>s   —〉  输出字符串</p>
<p>p    —-〉   输出地址指针</p>
<p>lu    —-〉   32位无符号整数</p>
<p>llu    —-〉   64位无符号整数</p>
<h3 id="3、考查C语言的赋值语句"><a href="#3、考查C语言的赋值语句" class="headerlink" title="3、考查C语言的赋值语句"></a>3、考查C语言的赋值语句</h3><p>自增、自减都是合法的赋值语句，例如：D–;   即为  D=D-1;</p>
<p>(i+1)是一个常量，常量不能做自增运算</p>
<h3 id="4、printf函数域宽描述符的理解"><a href="#4、printf函数域宽描述符的理解" class="headerlink" title="4、printf函数域宽描述符的理解"></a>4、printf函数域宽描述符的理解</h3><p>eg:int a = 1234;  printf(“%2d\n”,a);</p>
<p>上题应该输出什么？     ——&gt;    1234</p>
<p>特别注意：<strong>输出数据的实际精度并不主要决定于格式项中的域宽和精度，也不取决于输入的数据精度，而主要取决于数据在机器内的存储精度</strong> </p>
<h3 id="5、C语句"><a href="#5、C语句" class="headerlink" title="5、C语句"></a>5、C语句</h3><h5 id="1、”空语句出现在任何位置都不会影响程序运行”-是错误的"><a href="#1、”空语句出现在任何位置都不会影响程序运行”-是错误的" class="headerlink" title="1、”空语句出现在任何位置都不会影响程序运行”  是错误的"></a>1、”空语句出现在任何位置都不会影响程序运行”  是错误的</h5><p>​        例如在for循环中，循环条件语句为空时，则不判断循环条件，导致成为死循环</p>
<h5 id="2、什么叫“空语句”："><a href="#2、什么叫“空语句”：" class="headerlink" title="2、什么叫“空语句”："></a>2、什么叫“空语句”：</h5><p>C语言中所有语句以“；”结尾，如果只有一个分号，这个分号也是一条语句，成为“空语句”</p>
<h3 id="6、整型无符号数的输出"><a href="#6、整型无符号数的输出" class="headerlink" title="6、整型无符号数的输出"></a>6、整型无符号数的输出</h3><h5 id="1、-u的作用是按无符号的十进制形式输出整型数"><a href="#1、-u的作用是按无符号的十进制形式输出整型数" class="headerlink" title="1、%u的作用是按无符号的十进制形式输出整型数"></a>1、%u的作用是按无符号的十进制形式输出整型数</h5><p>整型无符号数的取值范围在0~65535之间，无符号数不能表示成小于0的负数。</p>
<p>十六进制数0xFFFF转换为二进制其值为16个1，代表的整数为65535</p>
<h3 id="7、数据输出"><a href="#7、数据输出" class="headerlink" title="7、数据输出"></a>7、数据输出</h3><p>1、scanf()和printf()是C语言提供的输入输出函数，不是语句</p>
<p>2、由printf()输出的数据都隐含右对齐</p>
<p>3、由printf输出的数据的实际精度是由格式控制中的小数的域宽来完全决定的。</p>
<p>4、在使用函数scanf()输入整数或实数时，输入数据时之间只能用逗号来分隔</p>
<p>5、printf函数中，输出项可以是任意的敞常量、变量、表达式</p>
<p>6、printf函数和scanf函数都可以指定输入数据的宽度</p>
<p>7、scanf函数中的格式字符是为了输入数据时用的</p>
<p>8、复合语句也成为语句块，在一对花括号内的语句数量不限</p>
<h2 id="二、选择结构"><a href="#二、选择结构" class="headerlink" title="二、选择结构"></a>二、选择结构</h2><h3 id="1、switch语句的应用"><a href="#1、switch语句的应用" class="headerlink" title="1、switch语句的应用"></a>1、switch语句的应用</h3><p>switch语句中，某分支执行完毕，若未遇到break，则接着执行剩余的其他分支，直到遇到break语句</p>
<h3 id="2、逻辑“或”运算"><a href="#2、逻辑“或”运算" class="headerlink" title="2、逻辑“或”运算   ||"></a>2、逻辑“或”运算   ||</h3><p>C语言中做逻辑“或”运算时，自左向右判断各个参加或运算的表达式，一旦运算到某式的值为非零时，表明整个表达式为真 ，余下的语句则不再进行运算。</p>
<h3 id="3、自增、自减运算"><a href="#3、自增、自减运算" class="headerlink" title="3、自增、自减运算"></a>3、自增、自减运算</h3><p>n++是在语句结束后再加1</p>
<h3 id="4、C语言基本数据类型"><a href="#4、C语言基本数据类型" class="headerlink" title="4、C语言基本数据类型"></a>4、C语言基本数据类型</h3><p>数据类型是所允许的数据及其操作的集合，是高级语言的重要特征。</p>
<p><strong>C语言提供了三大数据类型，即基本类型、复合类型和地址类型</strong></p>
<p>1、基本类型只代表单个数据</p>
<p>2、复合类型由基本类型组成，可代表一批数据；</p>
<p>3、地址类型可直接表示内存中的地址；</p>
<p>C语言支持的五种基本数据类型：</p>
<p>字符型：表示单个字符；</p>
<p>整型：表示整数，包括基本整型、短整型、长整型和无符号整型；</p>
<p>浮点型：表示实数，精度有6-7位有效数字；</p>
<p>双精度型：表示实数，进度为15-16位有效数字；</p>
<p>无值类型：表示无返回值的函数或无定向指针。</p>
<h3 id="5、关系表达式和逻辑表达式"><a href="#5、关系表达式和逻辑表达式" class="headerlink" title="5、关系表达式和逻辑表达式"></a>5、关系表达式和逻辑表达式</h3><p>关系表达式用来进行两个数据的比较，比较的结果为逻辑“真”或逻辑“假”</p>
<p>C语言不提供逻辑型数据，而是用整数0表示逻辑“假”，即比较不成立；用整数1表示逻辑“真”，即表示成立</p>
<p>和关系表达式一样，逻辑表达式的值也是用整数1表示逻辑“真”，用整数0表示逻辑“假”</p>
<p>eg：int a=5;b=4;c=3;    判断a&gt;b&gt;c 即相当于“(a&gt;b)&gt;c”,因为a&gt;b成立，所以其值为1，然后1和c比较；1&gt;c不成立。</p>
<h3 id="6、函数传值"><a href="#6、函数传值" class="headerlink" title="6、函数传值"></a>6、函数传值</h3><h5 id="1、值传递"><a href="#1、值传递" class="headerlink" title="1、值传递"></a>1、值传递</h5><p>作为值传递，在运行函数后不管函数里面对实参进行了什么运算，是不会改变实参的值的</p>
<h5 id="2、引用传递"><a href="#2、引用传递" class="headerlink" title="2、引用传递"></a>2、引用传递</h5><p>引用传递的时候是将参数的地址传递给了函数，这样函数中对实参所有操作都是直接在操作实参地址，所以引用传递能将实参值改变。</p>
<h5 id="3、指针传递"><a href="#3、指针传递" class="headerlink" title="3、指针传递"></a>3、指针传递</h5><p>将实参的地址传递给函数，将改变实参的值</p>
<h2 id="三、循环结构"><a href="#三、循环结构" class="headerlink" title="三、循环结构"></a>三、循环结构</h2><h3 id="1、do-while语句"><a href="#1、do-while语句" class="headerlink" title="1、do-while语句"></a>1、do-while语句</h3><p>C语言支持do-while语句和do-while构成的循环</p>
<p>当while值为0时结束循环，而不是非零</p>
<h2 id="四、字符型数据"><a href="#四、字符型数据" class="headerlink" title="四、字符型数据"></a>四、字符型数据</h2><h3 id="1、字符常量"><a href="#1、字符常量" class="headerlink" title="1、字符常量"></a>1、字符常量</h3><p>1）、转义字符常量是以一个反斜线开头后跟一个特定的字符，用来代表某个特定的ascii字符，反斜线后直接跟数字表示八进制（八进制不用0开头），八进制常量的数码取值为0-7</p>
<h3 id="2、转义字符"><a href="#2、转义字符" class="headerlink" title="2、转义字符"></a>2、转义字符</h3><p>在转义字符中，反斜杠后的八进制可以不用0开头，但是，八进制常量的数码取值为0-7，故’\82’ 不是八进制的转义字符。</p>
<p>反斜杠后的十六进制是用小写字符“x”开头的。</p>
<h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><h3 id="1、函数的反复调用"><a href="#1、函数的反复调用" class="headerlink" title="1、函数的反复调用"></a>1、函数的反复调用</h3><p>函数第一次调用后改变了函数的值，在第二次调用时用的依然是原始值</p>
<h3 id="2、C语言中的函数"><a href="#2、C语言中的函数" class="headerlink" title="2、C语言中的函数"></a>2、C语言中的函数</h3><h5 id="1、C语言在编译过程中是检查语法的，若发现源程序有语法错误，则系统会提示出错信息"><a href="#1、C语言在编译过程中是检查语法的，若发现源程序有语法错误，则系统会提示出错信息" class="headerlink" title="1、C语言在编译过程中是检查语法的，若发现源程序有语法错误，则系统会提示出错信息"></a>1、C语言在编译过程中是检查语法的，若发现源程序有语法错误，则系统会提示出错信息</h5><h5 id="2、子程序的作用是由函数来完成的，无过程的概念"><a href="#2、子程序的作用是由函数来完成的，无过程的概念" class="headerlink" title="2、子程序的作用是由函数来完成的，无过程的概念"></a>2、子程序的作用是由函数来完成的，无过程的概念</h5><h5 id="3、函数不可以嵌套定义，但可以嵌套使用"><a href="#3、函数不可以嵌套定义，但可以嵌套使用" class="headerlink" title="3、函数不可以嵌套定义，但可以嵌套使用"></a>3、函数不可以嵌套定义，但可以嵌套使用</h5><h3 id="3、C语言函数的缺省的函数类型"><a href="#3、C语言函数的缺省的函数类型" class="headerlink" title="3、C语言函数的缺省的函数类型"></a>3、C语言函数的缺省的函数类型</h3><p>C语言中，如果函数前不加任何数据类型时，缺省函数的类型为为整型，函数的类型就是函数返回值的类型。</p>
<h3 id="4、int-f-表示f是一个函数，带回一个指针值，这个指针值是指向一个整型数据的。"><a href="#4、int-f-表示f是一个函数，带回一个指针值，这个指针值是指向一个整型数据的。" class="headerlink" title="4、int * f() 表示f是一个函数，带回一个指针值，这个指针值是指向一个整型数据的。"></a>4、int * f() 表示f是一个函数，带回一个指针值，这个指针值是指向一个整型数据的。</h3><h2 id="六、地址和指针"><a href="#六、地址和指针" class="headerlink" title="六、地址和指针"></a>六、地址和指针</h2><h3 id="1、两个指针变量之间不能进行加运算"><a href="#1、两个指针变量之间不能进行加运算" class="headerlink" title="1、两个指针变量之间不能进行加运算"></a>1、两个指针变量之间不能进行加运算</h3><h3 id="2、指针变量的引用"><a href="#2、指针变量的引用" class="headerlink" title="2、指针变量的引用"></a>2、指针变量的引用</h3><p>如果给指针变量赋值为null，即空地址。</p>
<p>如果给空地址所指向的存储空间赋值的话，系统会出错。</p>
<h3 id="3、指针变量"><a href="#3、指针变量" class="headerlink" title="3、指针变量"></a>3、指针变量</h3><p>指针变量中只能存放地址(地址)，不要将一个整型量（或任何其他非地址类型的数据）赋给一个指针变量</p>
<p>相关运算符：</p>
<p>（1）、&amp;  取地址运算符</p>
<p>（2）、* 指针运算符（或称“间接访问”运算符）</p>
<blockquote>
<p>二级指针:如果一个指针指向的是另外一个指针,我们就称它为二级指针</p>
</blockquote>
<p> 指针变量可以指向整型变量、字符串、数组，也可以指向一个函数</p>
<p>eg：int (*f)(int)定义f是一个指向函数的指针变量，此函数带回整型的返回值，同时该函数还具有一个整型的形参</p>
<h3 id="4、指针的应用"><a href="#4、指针的应用" class="headerlink" title="4、指针的应用"></a>4、指针的应用</h3><h5 id="1、在16位编译系统上，若有定义int-a-10-20-30-p-a"><a href="#1、在16位编译系统上，若有定义int-a-10-20-30-p-a" class="headerlink" title="1、在16位编译系统上，若有定义int a[]={10,20,30},*p=&a;"></a>1、在16位编译系统上，若有定义int a[]={10,20,30},*p=&a;</h5><p>p=&amp;a表示指针p指向第一个元素a[0],执行p++是指使p指向下一个数据对象的地址，也就是向高地址迁移了一个存储单元，因为int数据占两个字节，所以p相当于向高地址迁移了两个字节。</p>
<h5 id="2、通过字符串指针进行字符长度的计算"><a href="#2、通过字符串指针进行字符长度的计算" class="headerlink" title="2、通过字符串指针进行字符长度的计算"></a>2、通过字符串指针进行字符长度的计算</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *t = s;</span><br><span class="line">    <span class="keyword">while</span>(*t++);</span><br><span class="line">    <span class="keyword">return</span> (t-s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个字符指针t，并将字符指针s的首地址赋予字符指针t</p>
<p>通过while语句将指针t下移到字符串最后一个字符’\0‘的地址，指针s始终指向首地址，将末地址减去首地址可以计算出字符串的长度。</p>
<h5 id="3、指针变量作函数参数的使用"><a href="#3、指针变量作函数参数的使用" class="headerlink" title="3、指针变量作函数参数的使用"></a>3、指针变量作函数参数的使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*a=<span class="string">&#x27;*&#x27;</span>) a++;</span><br><span class="line">    <span class="keyword">while</span> (*b=*a) </span><br><span class="line">    &#123;</span><br><span class="line">        b++;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">&quot;*****a*b****&quot;</span>,t[<span class="number">80</span>];</span><br><span class="line">    fun(s,t);</span><br><span class="line">    <span class="built_in">puts</span>(t);     <span class="comment">// puts()的作用是将一个字符串输出到终端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序的主函数定义了一个字符型指针变量s和字符型数组t；将s和t作为实参调用fun函数，使得形参指针变量a和b分别指向s和t所在存储单元的首地址，子函数中第一个while循环用于将指针变量a移动并指向非 “ * ” 字符的地址，即字符“a”的地址；第二个while循环的作用是将a指向的非“ * ” 字符开始的所有字符通过循环赋值方式赋给*b，由于指针变量b与字符数组t共用同一存储单元，所以对 * b的改变也是对数组t的改变，最终通过puts()函数输出数组的内容。</p>
<h3 id="5、指针变量的使用"><a href="#5、指针变量的使用" class="headerlink" title="5、指针变量的使用"></a>5、指针变量的使用</h3><h6 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>,n=<span class="number">2</span>,*p=&amp;m,*q=&amp;n,*r;</span><br><span class="line">    r=p;p=q;q=r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d,%d\n&quot;</span>,m,n,*p,*q);      <span class="comment">//  1,2,2,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序定义了指针变量p，q，r，其中p，q分别存放了变量m，n的地址，即p指向了1所存在存储单元，q指向了2所在的存储单元；p和q中存储的地址进行了交换，即p中存储的是n的地址，q中存储的是m的地址；但m，n的值并未改变。</p>
<h6 id="2、“-b-a”-表示将指针变量a所指向的值赋给-b-即将a所值字符串复制到b所指内存空间"><a href="#2、“-b-a”-表示将指针变量a所指向的值赋给-b-即将a所值字符串复制到b所指内存空间" class="headerlink" title="2、“ *b= *a” 表示将指针变量a所指向的值赋给 *b,即将a所值字符串复制到b所指内存空间"></a>2、“ *b= *a” 表示将指针变量a所指向的值赋给 *b,即将a所值字符串复制到b所指内存空间</h6><p>注意：“=”是赋值操作，而不是比较相等的符号“==”</p>
<h3 id="6、函数指针的运用"><a href="#6、函数指针的运用" class="headerlink" title="6、函数指针的运用"></a>6、函数指针的运用</h3><blockquote>
<p>函数指针的定义形式是：数据类型标识符 (*指针变量名)();</p>
</blockquote>
<p>void (*pf)()定义了一个没有返回值的函数指针pf，只需给出函数名而不必给出参数，所以给pf赋值时，只把函数名fun赋给pf即可</p>
<h3 id="7、常见的指针类型"><a href="#7、常见的指针类型" class="headerlink" title="7、常见的指针类型"></a>7、常见的指针类型</h3><table>
<thead>
<tr>
<th align="left">写法</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int *a;</td>
<td>a是指向整型的指针</td>
</tr>
<tr>
<td align="left">int* a[5];</td>
<td>一维指针数组（这里存放着五个指向整型的指针）；a指向第一个元素地址，a+1指向第二个</td>
</tr>
<tr>
<td align="left">int (*a)[5]</td>
<td>指向数组（一维数组含5个元素）的指针；a是第一个一维数组的首元素地址，a+1指向第二个一维数组的首元素地址</td>
</tr>
<tr>
<td align="left">int (*a)();</td>
<td>a是指向函数的指针（函数指针）</td>
</tr>
<tr>
<td align="left">int *a();</td>
<td>函数的返回类型是int *；a只是一个函数名</td>
</tr>
</tbody></table>
<h3 id="8、行指针"><a href="#8、行指针" class="headerlink" title="8、行指针"></a>8、行指针</h3><p>eg:  int a[3] [5];     a便是行指针</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>释义</th>
<th>指针类型</th>
</tr>
</thead>
<tbody><tr>
<td>a+0 或  &amp;a[0]</td>
<td>指向第一个一维数组的地址（指向第一行）</td>
<td>行指针</td>
</tr>
<tr>
<td>a+1 或 &amp;a[1]</td>
<td>指向第二个一维数组的地址（指向第二行）</td>
<td>行指针</td>
</tr>
<tr>
<td>a+2 或 &amp;a[2]</td>
<td>指向第三个一维数组的地址（指向第三行）</td>
<td>行指针</td>
</tr>
</tbody></table>
<h3 id="9、列指针"><a href="#9、列指针" class="headerlink" title="9、列指针"></a>9、列指针</h3><table>
<thead>
<tr>
<th>写法</th>
<th>释义</th>
<th>指针类型</th>
</tr>
</thead>
<tbody><tr>
<td>a[0]+0 或 &amp;a[0] [0]</td>
<td>指向第一行第一列的地址</td>
<td>列指针列指针</td>
</tr>
<tr>
<td>a[0]+1  或 &amp;a[0] [1]</td>
<td>指向第一行第二列的地址</td>
<td>列指针</td>
</tr>
<tr>
<td>a[1]+0 或  a[1] [0]</td>
<td>指向第二行第一列的地址</td>
<td></td>
</tr>
</tbody></table>
<h2 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h2><h3 id="1、通过指针引用数组元素"><a href="#1、通过指针引用数组元素" class="headerlink" title="1、通过指针引用数组元素"></a>1、通过指针引用数组元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">10</span>]=&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="number">0</span>&#125;,*p;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=<span class="number">8</span>;</span><br><span class="line">    p=a+i;</span><br><span class="line">    prinf(<span class="string">&quot;%s\n&quot;</span>,p<span class="number">-3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针p指向数组第九个元素，即a[8]=’9’；输出时，输出字符串，且指针把a[8]作为初始位置往前指3个元素，也就是共有4个字符输出。最后指向a[5]为’6‘；输出6789.</p>
<h3 id="2、数组指针的应用"><a href="#2、数组指针的应用" class="headerlink" title="2、数组指针的应用"></a>2、数组指针的应用</h3><p>int (*ptr)[m]中的标识符是一个指向具有M个整型元素的一维数组的指针</p>
<h3 id="3、指向指针的指针"><a href="#3、指向指针的指针" class="headerlink" title="3、指向指针的指针"></a>3、指向指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *alpha[<span class="number">6</span>]=&#123;<span class="string">&quot;ABCD&quot;</span>,<span class="string">&quot;EFGH&quot;</span>,<span class="string">&quot;IJKL&quot;</span>,<span class="string">&quot;MNOP&quot;</span>,<span class="string">&quot;QRST&quot;</span>,<span class="string">&quot;UVWX&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    p=alpha;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针数组*alpha[6]实际上相当于一个二维数组，而p是一个指向指针的指针，p=alpha后，引用p[x]便是引用数组 *alpha[6]中的第x个数组元素的首地址</p>
<h3 id="4、二维数组的取值"><a href="#4、二维数组的取值" class="headerlink" title="4、二维数组的取值"></a>4、二维数组的取值</h3><p>例如：a [3] [3] = { {1,2,3},{4,5,6},{7,8,9} }</p>
<table>
<thead>
<tr>
<th align="left">写法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td>代表整个数组得首地址，也是a[0]的首地址</td>
</tr>
<tr>
<td align="left">a+1</td>
<td>下一个元素的首地址  偏移一行，即a[1]的地址</td>
</tr>
<tr>
<td align="left">&amp;a</td>
<td>表示”整个“数组的首地址</td>
</tr>
<tr>
<td align="left">&amp;a+1</td>
<td></td>
</tr>
<tr>
<td align="left">a[0]</td>
<td>代表一维数组a[0]的首地址【a[0] [0]、a[0] [1]、a[0] [2]】</td>
</tr>
<tr>
<td align="left">a[0]+1</td>
<td>一维数组偏移了一个元素的地址</td>
</tr>
<tr>
<td align="left">&amp;a[0]</td>
<td>代表此数组首元素的首地址，即数组a[0]的首地址，与a相同，等价于行指针</td>
</tr>
<tr>
<td align="left">&amp;a[0]+1</td>
<td>偏移了一行，到下一个一维数组</td>
</tr>
<tr>
<td align="left">&amp;a[0] [0]</td>
<td>表示数组的首元素的首元素的地址</td>
</tr>
<tr>
<td align="left">&amp;a[0] [0] +1</td>
<td>表示偏移了此数组的首元素的首元素 即a[0] [1]的地址</td>
</tr>
</tbody></table>
<h3 id="5、选择法的算法"><a href="#5、选择法的算法" class="headerlink" title="5、选择法的算法"></a>5、选择法的算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun(<span class="keyword">int</span> *a.<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j=<span class="number">0</span>,p;    <span class="comment">// 变量p记录最小值数组的下标</span></span><br><span class="line">    p=j;   <span class="comment">// 在for循环之前，p的初值被赋为0</span></span><br><span class="line">    <span class="comment">// 先假设a[0]为数组中的最小值，然后通过for循环找到比a[0]还要小的值，将它的下标赋給p，即p=i</span></span><br><span class="line">    <span class="comment">// 那么此时a[p]为最小的数组值，接着再让a[p]与其他数组元素比较，直到比较完所有的数组元素，找出最小的数组元素下标p</span></span><br><span class="line">    <span class="keyword">for</span>(i=j;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[p])</span><br><span class="line">            p=i;</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、数组的定义和初始化"><a href="#6、数组的定义和初始化" class="headerlink" title="6、数组的定义和初始化"></a>6、数组的定义和初始化</h3><p>（1）、C语言中可以为数组赋初值，或部分赋值；当数组定义后，系统就会为其分配内存空间</p>
<p>eg： int a[10]={1,2,3};   假设int类型变量占两个字节</p>
<p>虽然数组a只有三个值，但系统仍为数组a分配了十个内存空间，所以数组a在内存中所占字节数为2*10=20</p>
<p>（2）、C语言中<strong>多维数组</strong>赋初始值时可以部分赋值，如果对全部元素赋值，则定义数组时对<strong>第一维的长度可以不指定，但第二维的长度不能省</strong></p>
<h3 id="7、函数返回数组中的最大值"><a href="#7、函数返回数组中的最大值" class="headerlink" title="7、函数返回数组中的最大值"></a>7、函数返回数组中的最大值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">findmax(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *p,*s;   </span><br><span class="line">    <span class="comment">// p,s都指向a[0]</span></span><br><span class="line">    <span class="keyword">for</span>(p=a,s=a;p-a&lt;n;p++)  <span class="comment">// p指针自加 即指针p遍历整个数组</span></span><br><span class="line">        <span class="keyword">if</span>(*p&gt;*s)   <span class="comment">// 用p指针指向的内容与s指针指向的内容作比较</span></span><br><span class="line">            s=p;   </span><br><span class="line">    <span class="keyword">return</span> (*s);   <span class="comment">// 通过返回值知道s代表数组元素最大值的地址，要实现这个目的，就要让s指针指向的内容与数组元素逐个进行比较，把较大值放进s中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">5</span>]=&#123;<span class="number">12</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,findmax(x,<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8、数组元素的引用"><a href="#8、数组元素的引用" class="headerlink" title="8、数组元素的引用"></a>8、数组元素的引用</h3><p>如果定义一个指针指向二维数组的一行，则可以移动到下一行，这就是行指针</p>
<p>行指针的定义格式： [存储类型]  数据类型(*指针)[n]  ;;这里的n是一个整数，表示所指向的二维数组的列数</p>
<h3 id="9、指向数组元素的指针"><a href="#9、指向数组元素的指针" class="headerlink" title="9、指向数组元素的指针"></a>9、指向数组元素的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> s[]=<span class="string">&quot;ABCD&quot;</span>,*P;</span><br><span class="line">    <span class="keyword">for</span>(p=s+<span class="number">1</span>;p&lt;s+<span class="number">4</span>;p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p=s+1 是指将s[1]的地址赋给p，循环终止条件是p&lt;s+4，s+4表示的是s[4]的地址，即运行到s[3]结束。</p>
<p>总共运行三次；；又因为输出形式是%s(字符串)   所以输出  BCD CD D</p>
<h2 id="八、字符串"><a href="#八、字符串" class="headerlink" title="八、字符串"></a>八、字符串</h2><blockquote>
<p>定义：<strong>是用一对双引号括起来的字符序列，并用字符型数组来存放</strong>；   正确写法：  <code>char str[]=&quot;\0&quot;;</code></p>
<p>用单引号或者缺少[]都是不对的。</p>
</blockquote>
<h3 id="1、strcpy-函数的应用"><a href="#1、strcpy-函数的应用" class="headerlink" title="1、strcpy()函数的应用"></a>1、strcpy()函数的应用</h3><p>假设定义一个： char *str3;    </p>
<p>直接为其strcpy(str3,”hello3”);是不正确的，字符数组或字符指针都应该在声明时分配内存空间，使用没有分配内存的指针是十分危险的</p>
<h3 id="2、字符串的连接和拷贝"><a href="#2、字符串的连接和拷贝" class="headerlink" title="2、字符串的连接和拷贝"></a>2、字符串的连接和拷贝</h3><blockquote>
<p>strcat(str1,str2) 字符串连接函数的作用是把str2所指字符串的内容连接到str1字符串后面，自动删去str1原来串中的‘\0’，为了进行这项操作，要求str1所指字符串后面有<strong>足够的空间</strong>来容纳str2所指字符串的内容</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *p1=<span class="string">&quot;abc&quot;</span>,*p2=<span class="string">&quot;ABC&quot;</span>,str[<span class="number">50</span>]=<span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str+<span class="number">2</span>,<span class="built_in">strcat</span>(p1,p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);        <span class="comment">// xyabcABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strcat(p1,p2)函数是将 *p1和 *p2指向的两个字符串连接起来，而strcpy()函数是将前者的结果拷贝到str字符串的第二个字符之后，覆盖了原来的“z”和“\0”</p>
<h3 id="3、字符串长度的计算"><a href="#3、字符串长度的计算" class="headerlink" title="3、字符串长度的计算"></a>3、字符串长度的计算</h3><table>
<thead>
<tr>
<th>符号</th>
<th>释义</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>TAB</td>
<td>1</td>
</tr>
<tr>
<td>\ \</td>
<td>\</td>
<td>1</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
<td>1</td>
</tr>
</tbody></table>
<p>strlen()计算长度从1开始，但是数组下标从0开始</p>
<h3 id="4、字符串与库函数"><a href="#4、字符串与库函数" class="headerlink" title="4、字符串与库函数"></a>4、字符串与库函数</h3><p>1、C语言中字符串是以’\0’字符结束的</p>
<p>2、strlen()函数计算的是‘\0’字符前所有字符的个数.</p>
<p>假设：<code>char p[]=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#125;; strlen(p);</code>p的长度并不能确定；strlen是计算以’\0’结束的字符串的长度的函数，函数的值为字符串中实际长度的值，不包括‘\0’,   因为p数组既没有给出数组的大小有没有结束符，所以长度不能确认。</p>
<p>3、sizeof()函数是计算变量或数组的所分配到的内存空间的大小，不论其中有没有内容</p>
<h3 id="5、字符数组与字符串的概念"><a href="#5、字符数组与字符串的概念" class="headerlink" title="5、字符数组与字符串的概念"></a>5、字符数组与字符串的概念</h3><p>C语言中不能将字符串常量直接赋给一数组；  例如:  <code>char s1[10]; s1=&quot;chest&quot;</code></p>
<p>但是赋初始值可以。 例如：<code>char *s2=&quot;Chest\n&quot;</code></p>
<h3 id="6、-strcmp-函数"><a href="#6、-strcmp-函数" class="headerlink" title="6、 strcmp()函数"></a>6、 strcmp()函数</h3><blockquote>
<p>根据ASCII编码对两个字符串进行比较，区分大小写；直到出现不同的字符，或者到达字符串的末尾（遇见‘\0’）</p>
</blockquote>
<p>返回值：</p>
<p>如果返回值&lt;0，则表示str1小于str2；</p>
<p>如果返回值&gt;0，则表示str1大于str2；</p>
<p>如果返回值=0，则表示str1等于str2；</p>
<p>eg:  <code>char name1[10]=&#123;&quot;zhangsan&quot;&#125;,name2[10]=&#123;&quot;zhaoliu&quot;&#125;; strcmp(name1,name2);</code></p>
<p>比较结果为  name1&gt;name2;  因为前面的‘z’、‘h’、‘a’都相等，所以继续比较第四个元素‘n’和‘o’；比较至此，已经有返回值了，所以停止后边的比较，并返回相应的值。</p>
<h3 id="7、puts-函数"><a href="#7、puts-函数" class="headerlink" title="7、puts()函数"></a>7、puts()函数</h3><blockquote>
<p>作用：将一个字符串(以‘\0’结束的字符序列)输出到终端，用puts函数输出字符串中可以包含转义字符，遇到转义字符，自动跳过去</p>
</blockquote>
<p>C规定：在每一个字符串的结尾加一个“字符串结束标志”，以便系统据此判断字符串是否结束；C规定以字符’\0’作为字符串结束标志。‘\0’是一个ASCII码为0的字符，从ASCII代码表中可以看到ASCII码为0的字符是“空操作符”，即它不引起任何控制动作，也不是一个可显示字符。</p>
<h3 id="8、字符串的读写"><a href="#8、字符串的读写" class="headerlink" title="8、字符串的读写"></a>8、字符串的读写</h3><h5 id="1、getchar"><a href="#1、getchar" class="headerlink" title="1、getchar()"></a>1、getchar()</h5><p>作用：从终端（或系统隐含指定的输入设备）输入一个字符，且只能接受一个字符（回车符也算是一个字符），getchar()不能用来读入字符串。</p>
<h5 id="2、scanf"><a href="#2、scanf" class="headerlink" title="2、scanf()"></a>2、scanf()</h5><p>scanf()函数要求按照一定的格式来输入，若同时输入多个字符串，则以空格或回车分割，所以空格不能被识别为一个字符，也无法读入空格字符</p>
<h5 id="3、gets"><a href="#3、gets" class="headerlink" title="3、gets()"></a>3、gets()</h5><p>函数gets()的作用是从终端输入一个字符串（包括空格），直到遇到换行为止，可以用键盘来读入空格字符。</p>
<h5 id="4、getc"><a href="#4、getc" class="headerlink" title="4、getc()"></a>4、getc()</h5><p>int getc(FILE * steam)从指定的流stream获取下一个字符（一个无符号字符），并把位置标识符往前移动。</p>
<h3 id="9、指针变量值的交换"><a href="#9、指针变量值的交换" class="headerlink" title="9、指针变量值的交换"></a>9、指针变量值的交换</h3><p>C语言中，字符串常量在内存中以字符数组的形式进行存放，因此字符指针x和y指向的是各字符串的首地址，也就是字符串第一个字符的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *x,<span class="keyword">char</span> *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t;</span><br><span class="line">    t=*x,*x=*y,*y=t;   <span class="comment">// *x与*y交换的是字符串的第一个字符，其它字符保持不变</span></span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1=<span class="string">&quot;abc&quot;</span>,*s2=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    swap(s1,s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s,%s\n&quot;</span>,s1,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="九、对函数的进一步讨论"><a href="#九、对函数的进一步讨论" class="headerlink" title="九、对函数的进一步讨论"></a>九、对函数的进一步讨论</h2><h3 id="1、指针数组main函数的参数"><a href="#1、指针数组main函数的参数" class="headerlink" title="1、指针数组main函数的参数"></a>1、指针数组main函数的参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(argv[<span class="number">1</span>][i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=fun();i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n*argc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    s+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argc和argv是main函数的形参。main函数是由系统调用的，当处于操作命令状态下，输入main所在的文件名（经过编译、链接后得到可执行文件名），系统就调用main函数。实参是和命令行一起给出的。也就是在一个命令行和需要传给main函数的参数。命令行的一般形式为：命令名 参数1 参数2……参数n        命令名和各参数之间用空格分隔。</p>
<p>argc是指命令行中的参数的个数，以上的程序题中有两个命令行参数exam和123。while循环实际是循环次数与第二个参数的字符个数相等。<strong>函数fun使用了静态变量。是一个计数函数，</strong>可以判断调用3次后n=3</p>
<h3 id="2、函数的递归调用"><a href="#2、函数的递归调用" class="headerlink" title="2、函数的递归调用"></a>2、函数的递归调用</h3><p>在调用一个函数的过程中又出现直接或间接地调用该函数本身，成为函数的递归调用；</p>
<p>在调用f1函数过程中要调用f2函数，而在调用f2函数过程中又要调用f1函数是间接调用，成为间接递归调用。</p>
<h2 id="十、C语言中用户标识符的作用和存储类"><a href="#十、C语言中用户标识符的作用和存储类" class="headerlink" title="十、C语言中用户标识符的作用和存储类"></a>十、C语言中用户标识符的作用和存储类</h2><h3 id="1、函数中变量的存储类"><a href="#1、函数中变量的存储类" class="headerlink" title="1、函数中变量的存储类"></a>1、函数中变量的存储类</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>隐含存储类别（动态存储）</td>
<td>是局部变量的默认存储类，限定变量只能在函数内部使用</td>
</tr>
<tr>
<td>register</td>
<td>寄存器存储类别（动态存储）</td>
<td>代表寄存器变量，不在内存（RAM）中使用</td>
</tr>
<tr>
<td>static</td>
<td>静态存储类别</td>
<td>表示变量在程序生命周期内可见</td>
</tr>
<tr>
<td>extern</td>
<td>外部变量声明（静态存储）</td>
<td>表明该变量是一个已经定义的外部变量。可以扩展全局变量的作用域</td>
</tr>
</tbody></table>
<h3 id="2、变量作用域"><a href="#2、变量作用域" class="headerlink" title="2、变量作用域"></a>2、变量作用域</h3><p>全局变量是可以在子函数中对其值作改变，且它也可作为函数间的值传递，当函数或子函数中定义了与全局变量名称相同的局部变量，则全局变量会被屏蔽。</p>
<p><strong>变量的使用遵循就近原则</strong>，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。</p>
<h3 id="3、变量存储属性的理解"><a href="#3、变量存储属性的理解" class="headerlink" title="3、变量存储属性的理解"></a>3、变量存储属性的理解</h3><p>一个变量被指定为静态变量（<strong>static</strong>），在编译时就为其分配了存储空间，程序一开始执行便被建立，直到该程序执行结束都存在，而不像动态变量只存在于函数或分程序被调用期间。</p>
<p><strong>在函数多次被调用的过程中静态局部变量的值具有可继承性。</strong></p>
<h3 id="4、全局变量和局部变量"><a href="#4、全局变量和局部变量" class="headerlink" title="4、全局变量和局部变量"></a>4、全局变量和局部变量</h3><p>若在定义局部变量不赋初值，则<strong>对static变量来说，编译时自动赋值0（对数值型变量）或空字符（对字符变量</strong>）；而对<strong>auto变量来说，如果不赋初值则它的值是一个不确定的值。</strong>这是因为每次函数调用结束后存储单元已释放，下次调用时又重新分配存储单元，而所分配的单元中的值是不确定的。</p>
<p><strong>未经赋值的全局变量值为0</strong></p>
<h3 id="5、静态局部变量"><a href="#5、静态局部变量" class="headerlink" title="5、静态局部变量"></a>5、静态局部变量</h3><p>对其只赋一次初值，以后每次调用函数时不在重新赋值，而是保留上次调用函数结束时的值。</p>
<blockquote>
<p>C程序函数中的形参不可以说明为static型变量</p>
</blockquote>
<p>对于auto变量来说，如果不赋初值则它的值是一个不确定的值。</p>
<h3 id="6、函数形参的存储类别"><a href="#6、函数形参的存储类别" class="headerlink" title="6、函数形参的存储类别"></a>6、函数形参的存储类别</h3><p>当在函数内部或符合语句内定义变量时，如果没有指定存储类，或使用了auto说明符。系统就认为所定义的变量具有自动类别</p>
<h2 id="十一、编译预处理和动态存储分配"><a href="#十一、编译预处理和动态存储分配" class="headerlink" title="十一、编译预处理和动态存储分配"></a>十一、编译预处理和动态存储分配</h2><h3 id="1、对C语言宏定义的理解"><a href="#1、对C语言宏定义的理解" class="headerlink" title="1、对C语言宏定义的理解"></a>1、对C语言宏定义的理解</h3><p>eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M N+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM (M+1)*M/2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NUM需要展开运算</span></span><br><span class="line">NUM = (<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">1</span>/<span class="number">2</span> = <span class="number">4</span>*<span class="number">2</span>+<span class="number">1</span>/<span class="number">2</span> = <span class="number">8</span>+<span class="number">0</span>  =<span class="number">8</span> </span><br></pre></td></tr></table></figure>

<h3 id="2、带参数的宏定义"><a href="#2、带参数的宏定义" class="headerlink" title="2、带参数的宏定义"></a>2、带参数的宏定义</h3><p>eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUDGE(y)		2.84+y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(a)		printf(<span class="meta-string">&quot;%d&quot;</span>,(int)(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT1(a)	PR(a);putchar(<span class="meta-string">&#x27;\n&#x27;</span>)</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">2</span>;</span><br><span class="line">    PRINT1(FUDGE(<span class="number">5</span>)*x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序中如果有带实参的宏，则<strong>按#define命令行中指定的字符串从左到右进行置换</strong>，如果串中包含宏中的形参，则将程序语句中相应的实参代替形参，如果宏定义中的字符串中的字符不是参数字符，则保留，形成置换的字符串。</p>
<p>所以以上是：<code>PRINT1(2.84+5*2) =&gt;  PRINT1(2.84+10) =&gt; PRINT1(12.84)</code>   后面转整型得12.</p>
<h3 id="3、结构体的长度"><a href="#3、结构体的长度" class="headerlink" title="3、结构体的长度"></a>3、结构体的长度</h3><p><strong>结构体变量所占内存长度是各成员的内存长度之和。</strong>每个成员占有其自己的内存单元。</p>
<p>例有以下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aa</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r1;      <span class="comment">// 2字节</span></span><br><span class="line">    <span class="keyword">double</span> r2;   <span class="comment">// 8字节</span></span><br><span class="line">    <span class="keyword">float</span> r3;    <span class="comment">// 4字节</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">uu</span>&#123;</span>	 <span class="comment">// 共用体在内存中所占的长度等于最长成员的长度。所以为8字节</span></span><br><span class="line">        <span class="keyword">char</span> u1[<span class="number">5</span>];     <span class="comment">// 5字节</span></span><br><span class="line">        <span class="keyword">long</span> u2[<span class="number">2</span>];	    <span class="comment">// 8字节</span></span><br><span class="line">    &#125;ua;</span><br><span class="line">&#125;maya;</span><br></pre></td></tr></table></figure>

<p><code>sizeof(struct aa)  的值应该为2+8+4+8=22字节</code></p>
<h3 id="4、malloc函数"><a href="#4、malloc函数" class="headerlink" title="4、malloc函数"></a>4、malloc函数</h3><blockquote>
<p>原型：extern void *malloc(unsigned int size);</p>
</blockquote>
<p>头文件：#include  &lt;malloc.h&gt;  或  #include &lt;alloc.h&gt;   (两者内容完全一致)</p>
<p>功能：分配长度为size字节的内存块</p>
<p>说明：如果分配成功则返回指向被分配内存的指针；否则返回空指针NULL。</p>
<p>当内存不再使用时，应使用free()函数将内存块释放。</p>
<p>应用：malloc()是在内存的动态存储区中分配一个长度为size的连续空间，此函数的值（即“返回值”）是一个指针，它的值是该分配域的起始地址，如果此函数未能成功地执行，则返回值为0.</p>
<h3 id="5、calloc函数"><a href="#5、calloc函数" class="headerlink" title="5、calloc函数"></a>5、calloc函数</h3><blockquote>
<p>模型：<code>void * calloc(unsigned int num,unsigned int size)</code></p>
</blockquote>
<p>作用：分配num个大小为size字节的空间。</p>
<h3 id="6、宏定义"><a href="#6、宏定义" class="headerlink" title="6、宏定义"></a>6、宏定义</h3><p>return语句用于被调函数带回的一个函数值，void关键字表示“无类型”，即不需要从被调函数中带回函数值，不需要return语句</p>
<p>无参宏的宏名后不带参数，其定义的一般形式为：<code>#define 标识符 字符串</code></p>
<p>‘标识符’为所定义的宏名，‘字符串’可以是参数、表达式、格式串等。</p>
<p>例如：<code>#define N 100</code>  它的作用是指定标识符N来代替参数100，在编写源程序时，所有的100都可由N代替，而对源程序作编译时，<strong>将先由预处理程序进行宏替换</strong>，然后再进行编译。</p>
<h3 id="7、预处理的概念"><a href="#7、预处理的概念" class="headerlink" title="7、预处理的概念"></a>7、预处理的概念</h3><p>通常，预处理命令位于源文件的开头，但不一定必须位于开头，也可以写在函数与函数之间</p>
<p>由于预处理命令的末尾不加分号，所以，不能在一行上写多条预处理命令，否则，系统处理时就会把它当作一条命令</p>
<p>宏名一般习惯用大写字母表示，以便与变量名相区别，但这并非规定，也可用小写字母。</p>
<p>宏替换不占用程序的运行时间。</p>
<blockquote>
<p>C提供三种预处理语句：</p>
<p>1、宏替换；2、文件包含；3、条件编译。</p>
</blockquote>
<h2 id="十二、结构体、共用体和用户定义类型"><a href="#十二、结构体、共用体和用户定义类型" class="headerlink" title="十二、结构体、共用体和用户定义类型"></a>十二、结构体、共用体和用户定义类型</h2><h3 id="1、结构体与共用体的区别"><a href="#1、结构体与共用体的区别" class="headerlink" title="1、结构体与共用体的区别"></a>1、结构体与共用体的区别</h3><p>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
<p><strong>结构体占用的内存大于等于所有成员占用的内存总和</strong>（成员之间可能存在缝隙），<strong>共用体占用的内存等于最长的成员占用的内存。</strong>共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
<h3 id="2、共用体类型数据的特点"><a href="#2、共用体类型数据的特点" class="headerlink" title="2、共用体类型数据的特点"></a>2、共用体类型数据的特点</h3><p>共用体的成员公用一段内存空间，当程序给第一个成员赋值之后，共用体其他成员的值也确定了</p>
<h3 id="3、结构体定义变量的方法"><a href="#3、结构体定义变量的方法" class="headerlink" title="3、结构体定义变量的方法"></a>3、结构体定义变量的方法</h3><h5 id="1、先定义结构体类型，再定义结构体变量"><a href="#1、先定义结构体类型，再定义结构体变量" class="headerlink" title="1、先定义结构体类型，再定义结构体变量"></a>1、先定义结构体类型，再定义结构体变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、定义结构体类型的同时，定义结构体变量"><a href="#2、定义结构体类型的同时，定义结构体变量" class="headerlink" title="2、定义结构体类型的同时，定义结构体变量"></a>2、定义结构体类型的同时，定义结构体变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;stu;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span>;</span>  <span class="comment">// 这样可以再次定义结构体变量</span></span><br></pre></td></tr></table></figure>

<h5 id="3、不定义结构体类型，直接定义结构体变量"><a href="#3、不定义结构体类型，直接定义结构体变量" class="headerlink" title="3、不定义结构体类型，直接定义结构体变量"></a>3、不定义结构体类型，直接定义结构体变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure>

<p>这样做的缺陷很大，这样的话就不能再次定义stu1该类型的结构体变量了，可移植性差，不灵活</p>
<h5 id="4、用typedef来定义结构体变量及类型"><a href="#4、用typedef来定义结构体变量及类型" class="headerlink" title="4、用typedef来定义结构体变量及类型"></a>4、用typedef来定义结构体变量及类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;Binode;</span><br></pre></td></tr></table></figure>

<p>这样定义的话，结构体类型的名字就有了两个分别为node和Binode。定义结构体变量的方式就有了两种：</p>
<p><code>struct node val1</code>和  <code>Binode val</code>2</p>
<h3 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h3><h2 id="十三、位运算"><a href="#十三、位运算" class="headerlink" title="十三、位运算"></a>十三、位运算</h2><h3 id="1、位运算符"><a href="#1、位运算符" class="headerlink" title="1、位运算符"></a>1、位运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td>参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果才为1，否则为0；参与运算的数以补码方式出现。</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>参与运算的两数各对应的二进位相或，只有对应的两个二进位有一个为1时，结果就为1；参与运算的两个数均已补码出现</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>当对应位上的二进制数值相同时，异或的结果为0，对应位上的二进制数值不同时，异或的结果为1</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>（单目运算符）具有右结合性，功能：参与运算的数的各二进位按位求反</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>左边的运算数各二进位全部左移若干位，由“&lt;&lt;”右边的数指定移动的位数；高位丢弃，低位补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>右边的运算数各二进位全部右移若干位</td>
</tr>
</tbody></table>
<h3 id="2、位运算符优先级："><a href="#2、位运算符优先级：" class="headerlink" title="2、位运算符优先级："></a>2、位运算符优先级：</h3><table>
<thead>
<tr>
<th><strong>优先级</strong></th>
<th><strong>运算符</strong></th>
<th><strong>名称或含义</strong></th>
<th><strong>使用形式</strong></th>
<th><strong>结合方向</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>5</strong></td>
<td><strong>&lt;&lt;</strong></td>
<td>左移</td>
<td>变量&lt;&lt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>&gt;&gt;</strong></td>
<td>右移</td>
<td>变量&gt;&gt;表达式</td>
<td>左到右</td>
<td></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>&amp;</strong></td>
<td>按位与</td>
<td>表达式&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>^</strong></td>
<td>按位异或</td>
<td>表达式^表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td><strong>|</strong></td>
<td>按位或</td>
<td>表达式|表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
</tbody></table>
<h2 id="十四、文件"><a href="#十四、文件" class="headerlink" title="十四、文件"></a>十四、文件</h2><h3 id="1、feof-函数"><a href="#1、feof-函数" class="headerlink" title="1、feof()函数"></a>1、feof()函数</h3><p>feof(fp)函数用来检测文件位置指针是否已指向文件的末尾，若已指向末尾，则函数值为非零值，否则函数值为0。</p>
<h3 id="2、C语言中的文件操作"><a href="#2、C语言中的文件操作" class="headerlink" title="2、C语言中的文件操作"></a>2、C语言中的文件操作</h3><p>C语言中有文本文件与二进制文件，对文件的使用前必须先打开，打开方式有只读、写入、读写等方式</p>
<h3 id="3、打开文件的方式"><a href="#3、打开文件的方式" class="headerlink" title="3、打开文件的方式"></a>3、打开文件的方式</h3><p>共有12种，由r(read), w(write), a(append), b(binary), +(read/write)五个字符组合而成。</p>
<p>“r”, “w”, “a”, “r+”, “w+”, “a+” ：这六种打开文本文件</p>
<p>“rb”, “wb”, “ab”, “rb+”, “wb+”, “ab+” ：这六种打开二进制文件</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>“r”</td>
<td>打开一个文本文件，可以读取文件</td>
</tr>
<tr>
<td>“w”</td>
<td>打开一个文本文件，可以写入文件，先将文件的长度截为0，如果该文件不存在则先创建</td>
</tr>
<tr>
<td>“a”</td>
<td>打开一个文本文件，可以写入文件，向已有文件的尾部追加内容，如果该文件不存在则先创建</td>
</tr>
<tr>
<td>“r+”</td>
<td>打开一个文本文件，可以进行更新（读取和写入），只对已有文件有效</td>
</tr>
<tr>
<td>“w+”</td>
<td>打开一个文本文件，可以进行更新（读取和写入），如果该文件存在则首先将其长度截为0，，如果该文件不存在则先创建</td>
</tr>
<tr>
<td>“a+”</td>
<td>打开一个文本文件，可以进行更新（读取和写入），向已有文件的尾部追加内容，如果该文件不存在则先创建，可以读取整个文件，但写入时只能追加内容</td>
</tr>
<tr>
<td>“rb”、“wb”、“ab”……</td>
<td>与前面的模式相似，只是使用二进制而非文本模式打开文件</td>
</tr>
</tbody></table>
<p><strong>注意：如果用“w”模式打开任意一个文件，文件内容将删除，以便程序以一个空文件开始操作。</strong></p>
<h3 id="4、二进制文件"><a href="#4、二进制文件" class="headerlink" title="4、二进制文件"></a>4、二进制文件</h3><p>二进制文件打开后可以先读文件的末尾，而顺序文件不可以</p>
<h3 id="5、C文件的基本概念"><a href="#5、C文件的基本概念" class="headerlink" title="5、C文件的基本概念"></a>5、C文件的基本概念</h3><p>C语言把文件看做是一个字符（字节）的序列，根据数据组织形式可分为ASCII文件（又称为文本文件）和二进制文件，即一个C文件可以看成是一个字节流或二进制流，对于流式文件，可以进行顺序读写，也可以进行随机读写；关键在于控制文件的位置指针，由于文本文件要发生字符转换，计算位置时往往会发生混乱，访问速度受到影响，所以随机读写方式不适用于文本文件。</p>
<h3 id="6、fread-函数和fwrite-函数"><a href="#6、fread-函数和fwrite-函数" class="headerlink" title="6、fread()函数和fwrite()函数"></a>6、fread()函数和fwrite()函数</h3><h5 id="1、fread"><a href="#1、fread" class="headerlink" title="1、fread()"></a>1、fread()</h5><p>作用：从指定文件中读取块数据，所谓块数据，也就是若干个字节的数据，可以是一个字符，也可以是一个字符串，也可以是多行数据。</p>
<blockquote>
<p>原型：size_t fread(void *ptr,size_t size,size_t count,FILE *fp);</p>
</blockquote>
<h5 id="2、fwrite"><a href="#2、fwrite" class="headerlink" title="2、fwrite()"></a>2、fwrite()</h5><p>作用：向文件中写入块数据</p>
<blockquote>
<p>原型：size_t fwrite(void * ptr,size_t size,size_t count,FILE *fp);</p>
</blockquote>
<p>参数说明：</p>
<ul>
<li>ptr 为内存区块的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>，它可以是数组、变量、结构体等。fread() 中的 ptr 用来存放读取到的数据，fwrite() 中的 ptr 用来存放要写入的数据。</li>
<li>size：表示每个数据块的字节数。</li>
<li>count：表示要读写的数据块的块数。</li>
<li>fp：表示文件指针。</li>
<li>理论上，每次读写 size*count 个字节的数据。</li>
</ul>

        </div>
        
        <div class="post-tag">
            
            <a class="tag" href="/tags/C%E8%AF%AD%E8%A8%80/" title="C语言">C语言</a>
            
        </div>
        
    </article>
</div>
<div class="paginator">
    
        
        
            <a class="next" href="/2021/10/01/first-blog/">
                <span class="nav-default">first-blog</span>
                <span class="nav-mobile">下一篇</span>
                <i class="iconfont icon-next"></i>
            </a>
        
    
</div>
<div id="comment-container"></div>
    </div>
</div>
<footer class="footer-social">
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2021
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin">Alexis</a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    
    var gitment = new Gitment({
        id: 'C语言学习笔记',
        owner: 'aoteman-web',
        repo: 'https://aoteman-web.github.io',
        oauth: {
            client_id: 'b6a67f3f4d79d7758b67',
            client_secret: '49ebb10bb0e2eadbf1a2b6e0b92632b09176b65d'
        }
    });
    gitment.render('comment-container');
    

</script>
</html>
